<style>
    .overlay { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
        backdrop-filter: blur(2px); z-index: 100;
    }
    .modal { background: white; width: 90%; max-width: 500px; border-radius: 12px; padding: 25px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); }
    .modal-header { font-size: 1.25rem; font-weight: bold; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
</style>

<!-- 只有当 isVisible 为 true 时显示 -->
<div class="overlay" s-show="isVisible">
    <div class="modal">
        <div class="modal-header" s-text="title">默认标题</div>
        <!-- 插槽：外部内容（表单）将显示在这里 -->
        <slot></slot>
    </div>
</div>

<script>
    $state.isVisible = false;
    
    // 监听外部的 s-show 属性 (注意：Core库里 s-show 是指令，但这里我们通过 props 传递状态来控制内部 CSS)
    // 实际上 Core 库会自动处理宿主元素的 display。
    // 这里我们做一个 trick：我们监听外部传给组件的 's-show' 是不起作用的（因为那是指令），
    // 但通常我们会传一个 prop 比如 'visible'。
    // *修正*：为了演示方便，我们在 app-root 里使用的是 s-show 控制组件本身的 display。
    // 但如果想做内部动画，我们需要一个 prop。
    
    // 在这个案例中，我们在 app-root 使用了 s-show="showModal" 在 <ui-modal> 标签上。
    // 这会直接控制 <ui-modal> 元素的 display: none/block。
    // 所以内部其实不需要逻辑来控制显示，内部始终显示即可，外部控制了 Host 的可见性。
    // 但为了让内部布局 flex 生效，我们内部默认写死显示，外部控制 Host。
</script>